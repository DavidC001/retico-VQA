from retico_core import AbstractModule, UpdateMessage, UpdateType
from retico_core.text import SpeechRecognitionIU
from retico_core.text import TextIU

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

import Levenshtein
from torch import le

class RobotASRFilterModule(AbstractModule):
    """
    A module that filters out text generated by an NLG component.
    """

    def __init__(self, max_similarity_threshold = 0.1, **kwargs):
        super().__init__(**kwargs)
        self._asr_buffer = ""
        self._tts_buffer = ""
        self.max_similarity_threshold = max_similarity_threshold

    @staticmethod
    def name():
        return "Robot ASR Filter Module"

    @staticmethod
    def description():
        return "A module that filters out text generated by an NLG component."

    @staticmethod
    def input_ius():
        return [SpeechRecognitionIU, TextIU]

    @staticmethod
    def output_iu():
        return SpeechRecognitionIU
    
    def process_update(self, update: UpdateMessage):
        out_um = UpdateMessage()
        for iu, ut in update:
            
            if not isinstance(iu, SpeechRecognitionIU):
                self._tts_buffer += self.normalize_str(iu.payload.strip())
                
            else: # ASR output
                if ut == UpdateType.COMMIT:
                    continue
                if ut == UpdateType.REVOKE:
                    # If we revoke, we should not process this IU
                    out_um.add_iu(iu, ut)
                    continue
                
                self._asr_buffer += self.normalize_str(iu.payload.strip() + ' ')
        
                similarity = self.compute_similarity(self._tts_buffer[:len(self._asr_buffer) - 1], self._asr_buffer, alpha=0.5)
                
                if similarity < self.max_similarity_threshold:
                    out_um.add_iu(iu, ut)
                else:
                    print(f"Filtered out ASR output due to high similarity with TTS output.")
                    
                if iu.final:
                    self._asr_buffer = ""
                    self._tts_buffer = ""
        self.append(out_um)

    
    def normalize_str(self, string):
        # Might not work for some languages as is
        return ''.join(char.lower() for char in string if (char and char.isalnum()) or char in ["'", "-", " "])
    
    def compute_similarity(self, a: str, b: str, alpha: float = 0.5) -> float:
        r"""
        Compute the hybrid similarity between two strings.
        The similarity is computed as a linear combination of cosine similarity and normalized Levenshtein distance, which is normalized to the range [0, 1]. The formula is:
        
        `$ similarity = \alpha * \cos(a, b) + (1 - \alpha) * \bigl(1 - \frac{\mathrm{lev}(a, b)}{\max(|a|, |b|)}\bigr) $`

        Parameters
        ----------
        a : str
            First input string.
        b : str
            Second input string.
        alpha : float
            The coefficient alpha is a float in [0, 1] that determines the weights of the cosine similarity and Levenshtein distance. The closer to 1, the more weight is given to the orthography, and the closer to 0, the more weight is given to the meaning.

        Returns
        -------
        float
            A value in [0,1] indicating combined semantic/orthographic similarity.
        """
        
        a = a.strip()
        b = b.strip()
        
        if len(a) == 0 or len(b) == 0:
            return 0.0
        
        # Normalized Levenshtein distance ([0, 1])
        dist = Levenshtein.distance(a, b)
        max_len = max(len(a), len(b)) or 1
        norm_lev = 1.0 - dist / max_len
        
        # Cosine similarity ([0, 1])
        try:
            vec = TfidfVectorizer().fit([a, b])
            tfidf = vec.transform([a, b])
            cosine = float(cosine_similarity(tfidf[0], tfidf[1])[0, 0])
        except ValueError as e: # No valid words in the input
            return 0.0
        
        return alpha * cosine + (1 - alpha) * norm_lev